import matplotlib.pyplot as plt
import numpy as np
import sklearn 
import sklearn.datasets
from sklearn.cluster import KMeans, DBSCAN

SEED=10

# Some helper functions required for this exercise 
def drawScatter(data, labels=None):
    ''' Draws data that has been generated by a sklearn generator in a scatter plot of matplotlib. '''
    if len(labels) == data.shape[0]:
        plt.scatter(data[:,0], data[:,1], c=labels, cmap='viridis')
    else:
        plt.scatter(data[:,0], data[:,1])
               
def drawScatterAndCentroids(data, labels, centroids):
    ''' Draws 3D data with labels as a scatter plot and '''
    drawScatter(data, labels)
    plt.scatter(centroids[:,0], centroids[:,1], c='red', marker='X', s=200.0)
    

def genData3():
    data, labels = sklearn.datasets.make_blobs(n_samples=200, n_features=2, centers=4, cluster_std=1.2, random_state=SEED)
    data = np.array([ (x, 10.0 * y) for (x, y) in data.copy() ]).reshape(-1, 2)
    return data, labels

def clusterKMeansAndPlot(data, K):
    # Number of clusters K
    kmeans = KMeans(n_clusters=K, algorithm='full')

    # Fitting the input data
    kmeans = kmeans.fit(data)

    # Getting the cluster labels
    kmeans_predicted_labels = kmeans.predict(data)

    # Centroid values
    kmeans_final_centroids = kmeans.cluster_centers_

    fig = plt.figure(figsize=(6, 6))
    drawScatterAndCentroids(data, kmeans_predicted_labels, kmeans_final_centroids)
      
def clusterKMeans(data, K):
    # Number of clusters K
    kmeans = KMeans(n_clusters=K, algorithm='full')

    # Fitting the input data
    kmeans = kmeans.fit(data)

    # Getting the cluster labels
    kmeans_predicted_labels = kmeans.predict(data)

    # Centroid values
    kmeans_final_centroids = kmeans.cluster_centers_
    
    # Return the generated cluster labels and the centroids.
    return (kmeans_predicted_labels, kmeans_final_centroids) 

def clusterObjectionKMeans(data, labels, centroids):
    ''' Compute the objection value of k-means (squared distances to cluster points) '''
    result = 0.0
    # loop all lines in the data
    for idx, d in enumerate(data):
        # get the centroid for the datapoint.
        label = labels[idx]
        c = centroids[label]
        
        # add the squared distance to its cluster centroid the result for the data point.
        result += np.linalg.norm(d - c) ** 2
        
    return result

def clusterDCSCAN(data, epsilon=3, minpts=2):
    model = DBSCAN(eps=epsilon, min_samples=minpts)
    labels = model.fit_predict(data)
    return labels

def clusterDBSCANAndPlot(data, epsilon=0.1, minpts=2):
    labels = clusterDCSCAN(data, epsilon=epsilon, minpts=minpts)
    drawScatter(data, labels)

        